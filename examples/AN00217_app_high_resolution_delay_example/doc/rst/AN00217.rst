.. include:: ../../README.rst

|newpage|

Overview
--------

This demo application shows how to interface to the microphone array in high resolution mode.

|appendix|
|newpage|

Demo Hardware Setup
------------------- 

Ensure that an XTAG is connected along with the microphone array via USB.

|newpage|

Launching the demo application
------------------------------

Build the application then run using ``xrun app_high_resolution_delay_example.xe``.

Task setup
----------

The PDM microphones interface task, high resolution delay task and the decimators have to be connected 
together and to the application (``example()``). There needs to be one ``decimate_to_pcm_4ch()`` task per
every four channels that need processing. The needs to be one ``hires_delay`` task per eight channels.
The PDM interface task, ``pdm_rx()`` can process eight channels so only one is needed per eight channels. 
The PDM interface needs to be connected to the high resolution interface via two streaming channels and 
connected to the two decimators via streaming channels. Finally, the decimators have to be connected to 
the application. This gives the following task diagram::

  streaming chan c_pdm_to_hires[2];
  streaming chan c_hires_to_dec[2];
  streaming chan c_ds_output[2];
  chan c_cmd;

  par{
    pdm_rx(p_pdm_mics, c_pdm_to_hires[0], c_pdm_to_hires[1]);
    hires_delay(c_pdm_to_hires,c_hires_to_dec, 2, c_cmd);
    decimate_to_pcm_4ch(c_hires_to_dec[0], c_ds_output[0]);
    decimate_to_pcm_4ch(c_hires_to_dec[1], c_ds_output[1]);
    example(c_ds_output, c_cmd);
  }
	
Note that the decimators have to be on the same tile as the application due to shared frame memory.	
Finally, there needs to be a channel between the ``hires_delay`` and the application in order to issue
the commands to change the taps on each delay line.

Frame memory
------------

For each decimator an block of memory must be allocated for storing FIR data. The size of the data 
block must be::
  
  Number of channels for that decimator * THIRD_STAGE_COEFS_PER_STAGE * Decimation factor * sizeof(int)

bytes. The data must also be double word aligned. For example::

  int data_0[4*THIRD_STAGE_COEFS_PER_STAGE*DF] = {0};
  int data_1[4*THIRD_STAGE_COEFS_PER_STAGE*DF] = {0};

Also the frame memory must also be a double word aligned array of length of at least 2.   

Configuration
-------------

Configuration for the example is achieved through::

   decimator_config_common dcc = {
                  0, // frame size log 2 is set to 0, i.e. one sample per channel will be present in each frame
                  1, // DC offset elimination is turned on
                  0, // Index bit reversal is off
                  0, // No windowing function is being applied
                  DF,// The decimation factor is set to 6
                  g_third_16kHz_fir, //This corresponds to a 16kHz output hence this coef array is used
                  0, // Gain compensation is turned off
                  0  // FIR compensation is turned off
          };
          decimator_config dc[2] = {
                  {
                          &dcc,
                          data_0,     // The storage area for the output decimator
                          {INT_MAX, INT_MAX, INT_MAX, INT_MAX},  // Microphone gain compensation (turned off)
                          4           // Enabled channel count
                  },
                  {
                          &dcc,
                          data_1,     // The storage area for the output decimator
                          {INT_MAX, INT_MAX, INT_MAX, INT_MAX}, // Microphone gain compensation (turned off)
                          4           // Enabled channel count
                  }
          };
          decimator_configure(c_ds_output, 2, dc);

All configuration options are enumerated in the Microphone array library. Once configured 
then the decimators require initialization via::
  
  decimator_init_audio_frame(c_ds_output, 2, buffer, audio, DECIMATOR_NO_FRAME_OVERLAP);

The the decimators will start presenting samples in the form of frames that can be accessed with::

  frame_audio *  current = decimator_get_next_audio_frame(c_ds_output, 2, buffer, audio, 2);
  
The return value of the above is a pointer to the frame that the application (``example()``) is allowed 
to access. The ``current`` structure contains the frame data in the ``data`` member. ``data`` is a 2D array
with the first index denoting the channel number and the second index denoting the frame index. The frame
index used 0 for the oldest samples and 2 to the power of ``dcc.frame_size_log2`` minus one as the newest
samples.
		  
		  
|newpage|

References
----------
  
.. nopoints::

  * XMOS Tools User Guide

    http://www.xmos.com/published/xtimecomposer-user-guide

  * XMOS xCORE Programming Guide

    http://www.xmos.com/published/xmos-programming-guide
  
  * XMOS Microphone Array Library

    http://www.xmos.com/support/libraries/lib_mic_array

|newpage|

Full source code listing
------------------------

Source code for main.xc
.......................

.. literalinclude:: app_high_resolution_delay_example.xc
  :largelisting:

|newpage|

