.. include:: ../../../README.rst

Overview
--------

Eight PDM microphones can be attached using each high channel count PDM
interface. The interface requires three logical cores as shown below:

.. figure:: chan4-8.pdf
            :width: 100%
                    
            High channel count PDM interface

The left most task samples 8 microphones, and filters the data to provide up to
eight 384 KHz data streams, split in two bundles of four channels. Two
processing threads each process four channels. The processing thread
decimates the signal to a user chosen sample rate (one of 48, 24, 16, 12,
or 8 KHz). After this a sequence of eight steps takes place:

* A number of channels are selected. The user selects between 0 and 4
  channels. The other channels are muted.

* Optionally, DC offset is eliminated on the each channel.

* The gain is corrected so that a maximum signal on the PDM microphone
  corresponds to a maximum signal on the PCM signal.

* Optionally, the individual gain of each microphone can be compensated.
  This can be used to, at manufacture time, compensate any differences in
  gains between the microphones in a system.

* Frames of data are generated (with a frame size of between 1 and 2048 samples).
  Optionally, frames can be set to overlap by half a frame.

* An optional windowing function is applied to each frame.

* The data can be stored in an index bit-reversed manner, so that it can be passed
  into an FFT without having to do any preprocessing.


Hardware characteristics
------------------------

The PDM microphones need a *clock input* and provide the PDM signal on a
*data output*. All PDM microphones share the same clock signal (buffered on
the PCB as appropriate), and output onto eight data wires that are
connected to a single 8-bit port:

.. _pdm_wire_table:

.. list-table:: PDM microphone data and signal wires
     :class: vertical-borders horizontal-borders
     
     * - *Clock*
       - Clock line, the PDM clock the used by the microphones to 
         drive the data out.
     * - *DQ_PDM*
       - The data from the PDM microphones on an 8 bit port.
       
The only port needed by the library is the 8-bit data port. The library
assumes that the input port is clocked using the PDM clock, and the library
does not know where the PDM clock comes from. If a clock block ``pdmclk``
is clocked at a 3.072 MHz rate, and if we assume that the 8-bit port is
``p_pdm_mics`` then the following statements will ensure that the PDM data
port is clocked from the PDM clock::

  configure_in_port(p_pdm_mics, pdmclk);
  start_clock(pdmclk);

The input clock for the microphones can be generated in a multitude of
ways. For example one can generate a 3.072 MHz clock on the board, or one
can use the XCORE to divide down 12.288 MHz master clock. Or, if clock
accuracy is not important, the internal 100 MHz reference can be divided down to provide an
approximate clock.

If an external master clock is input to the xcore on a 1-bit port
``p_mclk`` that runs at 4x the PDM desired PDM clock, then the PDM clock
can be generated by using the divider in a clock block::

  configure_clock_src_divide(pdmclk, p_mclk, 4);
  configure_port_clock_output(p_pdm_clk, pdmclk);
  configure_in_port(p_pdm_mics, pdmclk);
  start_clock(pdmclk);
  
Finally, an approximate clock can be generated from the 100 MHz reference
clock as follows::

  configure_clock_rate(pdmclk, 100, 32);
  configure_port_clock_output(p_pdm_clk, pdmclk);
  configure_in_port(p_pdm_mics, pdmclk);
  start_clock(pdmclk);

It should be noted that this is a 3.125 MHz clock, which is 1.7% off a true
3.072 MHz clock. This may be acceptable to simple VUIs.

Usage
-----

All PDM microphone functions are accessed via the ``mic_array.h`` header::

  #include <mic_array.h>

You also have to add ``lib_mic_array`` to the
``USED_MODULES`` field of your application Makefile.

An application must also define and include an extra header
``mic_array_conf.h`` which is used to describe the mandatory configuration
described later in this document.

The PDM microphone interface and two 4-channel decimators are instantiated as 
parallel tasks that run in a ``par`` statement. The two 4-channel decimators must 
connect to the PDM interface via streaming channels::

  #include <mic_array.h>
  #include "mic_array_conf.h"
  
  clock pdmclk;
  in buffered port:32 p_pdm_mics  = XS1_PORT_8B;
  in port             p_mclk      = XS1_PORT_1E;  
  out port            p_pdm_clk   = XS1_PORT_1F;
  
  int main() {
     par {
        streaming chan c_pdm_to_pcm0, c_pdm_to_pcm1;
        streaming chan c_ds_output[2];
    
        configure_clock_src_divide(pdmclk, p_mclk, 4);
        configure_port_clock_output(p_pdm_clk, pdmclk);
        configure_in_port(p_pdm_mics, pdmclk);
        start_clock(pdmclk);
    
        par {
            pdm_rx(p_pdm_mics, c_pdm_to_pcm0, c_pdm_to_pcm1);
            decimate_to_pcm_4ch(c_pdm_to_pcm0, c_ds_output[0]);
            decimate_to_pcm_4ch(c_pdm_to_pcm1, c_ds_output[1]);
            application(c_ds_output);
        }
    }
    return 0;
  }

There is a further requirement that any application of a ``decimate_to_pcm_4ch`` 
task must be on the same tile as the ``decimate_to_pcm_4ch`` task due to the sharaed
frame memory.
  

``mic_array_conf.h``
--------------------

An application that uses ``lib_mic_array`` must define the header file
``mic_array_conf.h``. This header must define:

   * MAX_FRAME_SIZE_LOG2

     This defines the maximum frame size (log 2) that the application could request to use.
     The application may request frame sizes from 0 to ``MAX_FRAME_SIZE_LOG2``. 
     This should be kept small as it governs the memory required for 
     a frame.
     
Optionally `mic_array_conf.h`` may define

   * DC_OFFSET_DIVIDER_LOG2

     The DC offset is removed with a high pass filter obeying the relation
	 Yn+1 = Yn * alpha + X where Y is the output sample and X is the input sample.
	 The constant alpha is 1 - 2^(-DC_OFFSET_DIVIDER_LOG2), therefore DC_OFFSET_DIVIDER_LOG2 
	 can be used to control the responsiveness of the filter vs the cut off frequency.
	 The default is 13, but setting this will override it. The value must not exceed 31.

	 
Four Channel Decimator
----------------------

The four channel decimator tasks are highly configurable tasks for outputting frames of 
various sizes and formats. They can be used to produce frames suitable for time domain applications
or pre-process the frames ready for an FFT for frequency domain applications. The four 
channel decimators, ``decimate_to_pcm_4ch()``, have a number of configuration options 
controlled by the structure ``decimator_config`` through the function ``decimator_configure``. 
The decimators are controlled by two structures: ``decimator_config_common`` and ``decimator_config``, 
where the former configuration is common to all microphones and the later is specific to the batch of 4
microphones it interfaces to. The application has the option to control the
following settings through ``decimator_config_common``:

* ``frame_size_log2``: This sets the frame size to a power of two. A frame will contain 
  2 to the power of frame_size_log2 samples of each channel. Set this to a maximum of ``MAX_FRAME_SIZE_LOG2``.
  
* ``apply_dc_offset_removal``: This controls if the DC offset removal should be enabled
  or not. Set to ``1`` to enable, or ``0`` to not apply DC offset removal.
  
* ``fir_decimation_factor``: This specifies the decimation factor to apply to the input
  after a 4x decimator has already been applied. The valid values
  are 2, 4, 6, 8, 12, 16. Common sample rates can be achieved by using
  these decimation factors as follows:

  ======================== ===================== ======== ========== =============
  fir_decimation_factor    decimate_to_pcm_4x    PDM_rx   PDM clock  Sample rate
  ======================== ===================== ======== ========== =============
  2                        8 x                   8 x      3.072 MHz  48 KHz
  4                        16 x                  8 x      3.072 MHz  24 KHz
  6                        24 x                  8 x      3.072 MHz  16 KHz
  8                        32 x                  8 x      3.072 MHz  12 KHz
  12                       48 x                  8 x      3.072 MHz  8 KHz
  2                        8 x                   8 x      2.8224 MHz 44.1 KHz
  4                        16 x                  8 x      2.8224 MHz 22.05 KHz
  ======================== ===================== ======== ========== =============
  
* ``coefs``: This is a pointer to an array of arrays containing the
  coefficients for the final stage of decimation. Set this to
  ``FIR_LUT(d)`` where ``d`` is the ``fir_decimation_factor``; ``FIR_LUT()``
  is defined in ``fir_decimator.h``.
  If you wish to supply your own FIR coefficients; the array
  should have the same number of entries as ``fir_decimation_factor``.
  
* ``fir_gain_compensation`` single value to compensate the gain of all the
  previous decimators. This must be set to a value that depends on the
  ``fir_decimation_factor`` as follows:
  
  ======================== ======================
  fir_decimation_factor    fir_gain_compression
  ======================== ======================
  2                         FIR_COMPENSATOR_48KHZ
  4                         FIR_COMPENSATOR_24KHZ
  6                         FIR_COMPENSATOR_16KHZ
  8                         FIR_COMPENSATOR_12KHZ
  12                        FIR_COMPENSATOR_8KHZ
  ======================== ======================
  
  If you wish to supply your own, this is a fixed
  point number in 1.4.27 format.
  
* ``apply_mic_gain_compensation``: Set this to ``1`` if microphone gain compensation is 
  required. The compensation applied is controlled through the
  ``mic_gain_compensation`` field in ``decimator_config`` below.
  
* A windowing function can be passed in through ``windowing_function``. It is a pointer
  to an array of integers that defines the windowing operator. Each sample
  in the frame is multiplied by its associated window value and shifted
  right by 31 places. This is performed before any index bit reversal (see
  the next entry).
  
* If the data is going to be post processed using an FFT, then
  ``index_bit_reversal`` can be set to 1. This will store the data elements
  reordered according to a reversed bit pattern, suitable for an FFT
  without "index bit reversing". As a side effect, it stores the data as
  complex numbers, in such a way that a single complex FFT operates on two
  microphones in parallel.

``decimator_config`` configures the per-channel information:

* ``dcc``: This is a pointer to the common decimator configuration.
  
* ``data``: This is the memory used to save the FIR samples. It must be an
  array of size (4 channels x ``THIRD_STAGE_COEFS_PER_STAGE`` x ``sizeof(int)`` x
  ``fir_decimation_factor`` bytes).
  
* ``mic_gain_compensation``: This is an array with four elements specifying
  the relative compensation to apply to each microphone. Unity gain is
  given by the value ``INT_MAX``. To equalise the gain of all microphones,
  the quietest microphone should be given unity gain, and the gain of all
  other microphones should be set proportionally lower.

* ``channel_count``: this is the number of channels that is enabled. Set
  this to 4 to enable all channels. If set to a value less than 4, only the
  first ``channel_count`` channels are enabled.

The decimator configuration is applied, from the application, by calling
the function ``decimator_configure`` with an array of chanends referring to
the decimators, a count of the number of decimators, and an array of
decimator configurations.

The output of the decimator is 32bit PCM audio at the requested sample rate. 
 
Frames
------

The four channel decimators output frames of either *simple audio* or
*complex audio* prepared for an FFT. The define ``MAX_FRAME_SIZE_LOG2``
(found in ``mic_array_conf.h``) should be used to allocate the arrays to
store the frames. This means that all frames structures will allocate
enough memory to allow for a frame size of two to the power of
``MAX_FRAME_SIZE_LOG2`` regardless of the size used in the
``decimator_config_common``. It is recommended that the ``frame_size_log2``
field of ``decimator_config_common`` is always set to ``MAX_FRAME_SIZE_LOG2``.


Simple audio
............

If *simple audio* output is used (``index_bit_reversal`` is set to 0), then
data is stored into eight arrays of length two to the power of
``MAX_FRAME_SIZE_LOG2`` where the first two to the power of ``frame_size_log_2`` 
entries contain valid data. The first index of the ``data`` element of
``frame_audio`` is used to address the microphone and the second index is
used for the sample number with 0 being the oldest sample.

Frames are initialised by the application by a call to
``decimator_init_audio_frame``. Pass it:

* ``c_from_decimator``: An array of channels to the decimators

* ``decimator_count``: A count of the number of decimators (the number of
  elements in the above array)

* ``buffer``: used internally to maintain ownership of the shared memory between  
  the application and the decimators.

* ``f_audio``: the array of audio frames, one (or two) of which will be owned by the 
  decimators at all times.

* ``buffering_type``: one of ``DECIMATOR_NO_FRAME_OVERLAP`` and
  ``DECIMATOR_HALF_FRAME_OVERLAP``. The former creates normal frames, where
  the last audio sample of the first frame is the sample just prior to the
  first audio sample of the second frame. The latter makes sure that
  subsequent frames have a 50% overlap; that is, the last audio sample of
  the first frame is the sample just prior to the middle sample of the
  second frame.


Calls to ``decimator_get_next_audio_frame()`` should be made to retrieve
subsequent audio frames.

* ``c_from_decimator``: An array of channels to the decimators

* ``decimator_count``: A count of the number of decimators (the number of
  elements in the above array)

* ``buffer``: used internally to share the frames between the application and 
  deciamtors in a round robin fashion.

* ``f_audio``: the array of audio frames, one (or two) of which will be owned by the 
  decimators at all times.

* ``buffer_count``: The number of frames in the ``f_audio`` array.

Complex audio
.............

If *complex audio* output is used (``index_bit_reversal`` is set to 1),
then the data is stored in frames that are designed to be processed with an
FFT. The data is stored in four arrays of length two to the power of
``MAX_FRAME_SIZE_LOG2`` where the first two to the power of ``frame_size_log_2`` 
entries contain valid data, each element storing a real and an imaginary
part. The data is stored in a bit reversed order (ie, the oldest element is
at index 0b0000....0000, the next oldest is at element 0b1000...0000, the
next one at element 0b0100...0000, etc up to element 0b1111...1111), and
the real elements store the even channels, whereas the imaginary elements
store the odd channels. A postprocess function must be applied after the
DIT-FFT in order to recover the frequency bins.

Frames are initialised by the application by a call to
``decimator_init_complex_frame``. Pass it:

* ``c_from_decimator``: An array of channels to the decimators

* ``decimator_count``: A count of the number of decimators (the number of
  elements in the above array)

* ``buffer``: used internally to maintain ownership of the shared memory between  
  the application and the decimators.

* ``f_complex``: the array of complex frames, one (or two) of which will be owned by the 
  decimators at all times.

* ``buffering_type``: one of ``DECIMATOR_NO_FRAME_OVERLAP`` and
  ``DECIMATOR_HALF_FRAME_OVERLAP``. The former creates normal frames, where
  the last audio sample of the first frame is the sample just prior to the
  first audio sample of the second frame. The latter makes sure that
  subsequent frames have a 50% overlap; that is, the last audio sample of
  the first frame is the sample just prior to the middle sample of the
  second frame.

Calls to ``decimator_get_next_complex_frame()`` should be made to retrieve
subsequent audio frames.

* ``c_from_decimator``: An array of channels to the decimators

* ``decimator_count``: A count of the number of decimators (the number of
  elements in the above array)

* ``buffer``: used internally to share the frames between the application and 
  deciamtors in a round robin fashion.

* ``f_complex``: the array of audio frames, one (or two) of which will be owned by the 
  decimators at all times.

* ``buffer_count``: The number of frames in the ``f_complex`` array.


Signal Characteristics
----------------------

The output signal has been decimated from the original PDM in such a way to achieve at 
least 100dBs of signal to noise for all output sample rates.

  ======================== ===================== =============
  fir_decimation_factor    Passband Cut Off      Sample rate
  ======================== ===================== =============
  2                        19kHz                 48 KHz
  4                        10.4kHz               24 KHz
  6                        7.1kHz                16 KHz
  8                        5kHz                  12 KHz
  12                       3.5kHz                8 KHz
  2                        17.5kHz               44.1 KHz
  4                        9.6kHz                22.05 KHz
  ======================== ===================== =============

The decimation is achieved by applying three polyphase FIR filters sequentially. 
The design of these filters can be view in the matlab script ``fir_design.m``. 

Example Applications
--------------------

Examples of of how to set up phased aligned sampling are given in the
application ``app_synchronous_delay_example`` with a worked example of a
fixed beam delay and sum beam-former given in the application
``example_lores_DAS_fixed``.

API
---

Creating an PDM Microphone interface instance
.............................................

.. doxygenfunction:: pdm_rx

|newpage|

PDM Microphone processing
.........................

.. doxygenfunction:: decimate_to_pcm_4ch
.. doxygenfunction:: decimate_configure
.. doxygenstruct:: decimator_config_common
.. doxygenstruct:: decimator_config

|newpage|

PCM frame interfacing
.....................

.. doxygenenum:: e_decimator_buffering_type
.. doxygenfunction:: decimator_init_audio_frame
.. doxygenfunction:: decimator_get_next_audio_frame
.. doxygenfunction:: decimator_init_complex_frame
.. doxygenfunction:: decimator_get_next_complex_frame

|newpage|

Frame types
...........

.. doxygenstruct:: complex
.. doxygenstruct:: frame_audio
.. doxygenstruct:: frame_complex

|newpage|

Known Issues
------------

This is an early release of the library. We envisage to extend this library
with functions for high-resolution delay adjustments.

This revision is only intended for internal XMOS use.

.. include:: ../../../CHANGELOG.rst
