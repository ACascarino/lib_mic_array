.. include:: ../../../README.rst

Overview
--------

This guide is designed so that the user can understand how to use ``lib_mic_array``
by reading up to :ref:`section_examples`. :ref:`section_dc` and on are designed to explain 
implementation details of ``lib_mic_array``, but do not need to be understood to use 
it effectively.

Up to eight PDM microphones can be attached to each high channel count PDM
interface(``pdm_rx()``). One or two processing threads, ``decimate_to_pcm_4ch()``, 
each process up to four channels. The interface requires either two:

  .. figure:: chan1-4.pdf
	:width: 100%
	    
	One to four channel count PDM interface

Or three logical cores as shown below:

  .. figure:: chan4-8.pdf
            :width: 100%
                    
            Five to eight count PDM interface

The left most task, ``pdm_rx()``, samples 8 microphones and filters the data to provide up to
eight 384 KHz data streams, split in two streams of four channels. The processing thread
decimates the signal to a user chosen sample rate (one of 48, 24, 16, 12,
or 8 KHz). If more than 8 channels are required then another ``pdm_rx`` task can be created.
After the decimation to the output sample rate the sequence of steps takes place:

* Optionally, DC offset is eliminated on the each channel.

* The gain is corrected so that a maximum signal on the PDM microphone
  corresponds to a maximum signal on the PCM signal.

* Optionally, the individual gain of each microphone can be compensated.
  This can be used to, at manufacture time, compensate any differences in
  gains between the microphones in a system.

* Frames of data are generated (with a frame size of 1 to 2048 in powers of two).
  Optionally, frames can be set to overlap by half a frame.

* An optional windowing function is applied to each frame.

* The data can be stored in an index bit-reversed manner, so that it can be passed
  into an FFT without having to do any preprocessing.


There is also an optional high resolution delay, running at up to 384kHz, that can be used to add to the 
signal path channel specific delays. This can be used for high resolution delay and sum
beamforming. The task diagrams for 4 and 8 channel microphone arrays are given in 
:ref:`figfourchanhires` and :ref:`figeightchanhires` respectivly.

.. _figfourchanhires:
.. figure:: chan1-4hires.pdf
	:width: 100%
	    
	One to four channel count PDM interface with hires delay lines


.. _figeightchanhires:
.. figure:: chan4-8hires.pdf
            :width: 100%
                    
            Five to eight count PDM interface with hires delay lines



Hardware characteristics
------------------------

The PDM microphones need a *clock input* and provide the PDM signal on a
*data output*. All PDM microphones share the same clock signal (buffered on
the PCB as appropriate), and output onto eight data wires that are
connected to a single 8-bit port:

.. _pdm_wire_table:

.. list-table:: PDM microphone data and signal wires
     :class: vertical-borders horizontal-borders
     
     * - *CLOCK*
       - Clock line, the PDM clock the used by the microphones to 
         drive the data out.
     * - *DQ_PDM*
       - The data from the PDM microphones on an 8 bit port.
       
The only port needed by the library is the 8-bit data port. The library
assumes that the input port is clocked using the PDM clock, and the library
does not know where the PDM clock comes from. If a clock block ``pdmclk``
is clocked at a 3.072 MHz rate, and if we assume that the 8-bit port is
``p_pdm_mics`` then the following statements will ensure that the PDM data
port is clocked from the PDM clock::

  configure_in_port(p_pdm_mics, pdmclk);
  start_clock(pdmclk);

The input clock for the microphones can be generated in a multitude of
ways. For example one can generate a 3.072 MHz clock on the board, or one
can use the xCORE to divide down 12.288 MHz master clock. Or, if clock
accuracy is not important, the internal 100 MHz reference can be divided down to provide an
approximate clock.

If an external master clock is input to the xCORE on a 1-bit port
``p_mclk`` that is running at 4x the desired PDM clock, then the PDM clock
can be generated by using the divider in a clock block::

  configure_clock_src_divide(pdmclk, p_mclk, 4);
  configure_port_clock_output(p_pdm_clk, pdmclk);
  configure_in_port(p_pdm_mics, pdmclk);
  start_clock(pdmclk);
  
An approximate clock can be generated from the 500 MHz xCORE clock as follows::

  configure_clock_xcore(pdmclk, 81);
  configure_port_clock_output(p_pdm_clk, pdmclk);
  configure_in_port(p_pdm_mics, pdmclk);
  start_clock(pdmclk);

It should be noted that this is a 3.048 MHz clock, which is 0.75% off a true
3.072 MHz clock. Finally, an approximate clock can also be generated from the 100 MHz reference
clock as follows::

  configure_clock_ref(pdmclk, 34);
  configure_port_clock_output(p_pdm_clk, pdmclk);
  configure_in_port(p_pdm_mics, pdmclk);
  start_clock(pdmclk);

This gives a 2.941 MHz clock, which is 4.25% off a true 3.072 MHz clock. This may be acceptable 
to simple Voice User Interfaces (VUIs).

PDM microphones
...............
There is a maximum 28ms delay at startup during which the PDM microphones are in initialization.   

Usage
-----

All PDM microphone functions are accessed via the ``mic_array.h`` header::

  #include <mic_array.h>

You also have to add ``lib_mic_array`` to the
``USED_MODULES`` field of your application Makefile.

An project must also include an extra header ``mic_array_conf.h`` which is used 
to describe the mandatory configuration described later in this document.

The PDM microphone interface and 4-channel decimators are instantiated as 
parallel tasks that run in a ``par`` statement. For example, in an eight channel setup the two 4-channel decimators must 
connect to the PDM interface via streaming channels::

  #include <mic_array.h>
  
  clock pdmclk;
  in buffered port:32 p_pdm_mics  = XS1_PORT_8B;
  in port             p_mclk      = XS1_PORT_1E;  
  out port            p_pdm_clk   = XS1_PORT_1F;
  
  int main() {
        streaming chan c_pdm_to_dec[2];
        streaming chan c_ds_output[2];
    
        configure_clock_src_divide(pdmclk, p_mclk, 4);
        configure_port_clock_output(p_pdm_clk, pdmclk);
        configure_in_port(p_pdm_mics, pdmclk);
        start_clock(pdmclk);
    
        par {
            pdm_rx(p_pdm_mics, c_pdm_to_dec[0], c_pdm_to_dec[1]);

            decimate_to_pcm_4ch(c_pdm_to_dec[0], c_ds_output[0]);
            decimate_to_pcm_4ch(c_pdm_to_dec[1], c_ds_output[1]);

            application(c_ds_output);
        }
        return 0;
  }

There is a further requirement that any application of a ``decimate_to_pcm_4ch`` 
task must be on the same tile as the ``decimate_to_pcm_4ch`` task due to the sharaed
frame memory.
  
Additionally, the high resolution delay task can be inserted between the PDM interface 
and the decimators, similar to the above, it is done in the following fashion::

  #include <mic_array.h>
  
  clock pdmclk;
  in buffered port:32 p_pdm_mics  = XS1_PORT_8B;
  in port             p_mclk      = XS1_PORT_1E;  
  out port            p_pdm_clk   = XS1_PORT_1F;
  
  int main() {
        streaming chan c_pdm_to_hires[2];
        streaming chan c_hires_to_dec[2];
        streaming chan c_ds_output[2];
        chan c_cmd;
    
        configure_clock_src_divide(pdmclk, p_mclk, 4);
        configure_port_clock_output(p_pdm_clk, pdmclk);
        configure_in_port(p_pdm_mics, pdmclk);
        start_clock(pdmclk);
    
        par {
            pdm_rx(p_pdm_mics, c_pdm_to_hires[0], c_pdm_to_hires[1]);

            hires_delay(c_pdm_to_hires, c_hires_to_dec, 2, c_cmd);

            decimate_to_pcm_4ch(c_hires_to_dec[0], c_ds_output[0]);
            decimate_to_pcm_4ch(c_hires_to_dec[1], c_ds_output[1]);

            application(c_ds_output, c_cmd);
        }
        return 0;
  }
  
  
Note, using the high resolution delay consumes an extra core.


High resolution delay task
--------------------------
The high resolution delay task, ``hires_delay()``, is capable to implementing delays 
with a resolution of up to 1.3 microseconds(384kHz). It implements 8 delays lines of length 
``HIRES_MAX_DELAY``, which has a default of 32. The delay line length can be overridden 
by defining it in ``mic_array_conf.h``. Each delay line sample is clocked at the PDM clock
rate divided by 8, that is, 384kHz for a 3.072MHz PDM clock and 352.8kHz for an PDM clock
of 2.8224MHz. 
By setting a positive delay of N samples on a channel then an input sample will take N extra 
clocks to propagate to the decimators. Setting of the taps is done through the function 
``hires_delay_set_taps()`` which will do an atomic update of all the active delay lines tap 
positions at once. The default delay on each channel is zero.


Frames
------

The four channel decimators (``pdm_rx()``) output frames of either *simple audio* or
*complex audio* prepared for an FFT. The define ``MAX_FRAME_SIZE_LOG2``
(found in ``mic_array_conf.h``) should be used to allocate the arrays to
store the frames. This means that all frames structures will allocate
enough memory to allow for a frame size of two to the power of
``MAX_FRAME_SIZE_LOG2`` regardless of the size used in the
``decimator_config_common``. It is recommended that the ``frame_size_log2``
field of ``decimator_config_common`` is always set to ``MAX_FRAME_SIZE_LOG2``.


Simple audio
............

If *simple audio* output is used (``index_bit_reversal`` is set to 0), then
data is stored into eight arrays of length two to the power of
``MAX_FRAME_SIZE_LOG2`` where the first two to the power of ``frame_size_log_2`` 
entries contain valid data. The first index of the ``data`` element of
``frame_audio`` is used to address the microphone and the second index is
used for the sample number with 0 being the oldest sample.

Frames are initialised by the application by a call to
``decimator_init_audio_frame``. Pass it:

* ``c_from_decimator``: An array of channels to the decimators

* ``decimator_count``: A count of the number of decimators (the number of
  elements in the above array)

* ``buffer``: used internally to maintain ownership of the shared memory between  
  the application and the decimators.

* ``f_audio``: the array of audio frames, one (or two) of which will be owned by the 
  decimators at all times.

* ``dcc``: the configuration to the decimators


Calls to ``decimator_get_next_audio_frame()`` should be made to retrieve
subsequent audio frames.

* ``c_from_decimator``: An array of channels to the decimators

* ``decimator_count``: A count of the number of decimators (the number of
  elements in the above array)

* ``buffer``: used internally to share the frames between the application and 
  deciamtors in a round robin fashion.

* ``f_audio``: the array of audio frames, one (or two) of which will be owned by the 
  decimators at all times.

* ``dcc``: the configuration to the decimators

Complex audio
.............

If *complex audio* output is used (``index_bit_reversal`` is set to 1),
then the data is stored in frames that are designed to be processed with an
FFT. The data is stored in four arrays of length two to the power of
``MAX_FRAME_SIZE_LOG2`` where the first two to the power of ``frame_size_log2`` 
entries contain valid data, each element storing a real and an imaginary
part. The data is stored in a bit reversed order (ie, the oldest element is
at index 0b0000....0000, the next oldest is at element 0b1000...0000, the
next one at element 0b0100...0000, etc up to element 0b1111...1111), and
the real elements store the even channels, whereas the imaginary elements
store the odd channels. A postprocess function must be applied after the
Decimate-in-Time(DIT) FFT in order to recover the frequency bins.

Frames are initialised by the application by a call to
``decimator_init_complex_frame``. Pass it:

* ``c_from_decimator``: An array of channels to the decimators

* ``decimator_count``: A count of the number of decimators (the number of
  elements in the above array)

* ``buffer``: used internally to maintain ownership of the shared memory between  
  the application and the decimators.

* ``f_complex``: the array of complex frames, one (or two) of which will be owned by the 
  decimators at all times.

* ``dcc``: the configuration to the decimators

Calls to ``decimator_get_next_complex_frame()`` should be made to retrieve
subsequent audio frames.

* ``c_from_decimator``: An array of channels to the decimators

* ``decimator_count``: A count of the number of decimators (the number of
  elements in the above array)

* ``buffer``: used internally to share the frames between the application and 
  deciamtors in a round robin fashion.

* ``f_complex``: the array of audio frames, one (or two) of which will be owned by the 
  decimators at all times.

* ``dcc``: the configuration to the decimators


Using the decimators
--------------------


Setting up the decimators
.........................

All decimators attached to an application, via streaming channels, are configured 
simultaneously with the ``decimator_configure()`` function. The parameters to the
``decimator_configure()`` function are described in a :ref:`section_api`. To start the 
frame exchange process ``decimator_init_audio_frame()`` or  ``decimator_init_complex_frame()`` must be called. Now the decimators are running
and will be outputting frames at the rate given by their configuration.

  .. _figstatemachine:
  .. figure:: state_machine.pdf
	:width: 100%
	    
	Order of the function calls allowed to the decimators.

The configuration of the decimators can be changed at any time so long as the 
function calls respect the control flow given in :ref:`figstatemachine`.

Changing decimator configuration
................................

Once the decimators are running the configuration of the decimators remain constant. If a change of configuration 
is required then a call to ``decimator_configure()`` allows a complete reconfigure. This will 
reconfigure and reset all attached decimators. The only configuration that will survive reconfiguration
is the DC offset memory. It is assumed that the microphone specific DC offset 
remains fairly constant between reconfigurations. 

Accessing the samples
---------------------
Samples are accessed in the form of frames. A frame is either in the simple audio format, ``frame_audio``,
or in the frequency domain format, ``frame_complex``. 

Simple audio frames contain a single two dimensional array, ``data``,
with the first index being the channel ID and the second dimension being the sample number. Samples are ordered 
``0`` as the oldest sample and increasing number being the newer.

Complex audio frames contain a single two dimensional array, ``data``. The data is packed into the array by 
even channels going into the real entries and odd channels going into the imaginary entries. Samples
are inserted into the array in an index bit-reversed order. This results in frames that are ready for direct
processing by an DIT FFT.

  .. _figmemory:
  .. figure:: memory_layout.pdf
	:width: 70%
	    
	Memory layout of simple audio and complex frames.

  
``mic_array_conf.h``
--------------------

An application that uses ``lib_mic_array`` must define the header file
``mic_array_conf.h``. This header must define:

   * MAX_FRAME_SIZE_LOG2

     This defines the maximum frame size (log 2) that the application could request to use.
     The application may request frame sizes from 0 to ``MAX_FRAME_SIZE_LOG2``. 
     This should be kept small as it governs the memory required for 
     a frame.
     
Optionally, ``mic_array_conf.h`` may define

   * DC_OFFSET_DIVIDER_LOG2

     The DC offset is removed with a high pass filter. ``DC_OFFSET_DIVIDER_LOG2``
	 can be used to control the responsiveness of the filter vs the cut off frequency.
	 The default is 13, but setting this will override it. The value must not exceed 31.
	 See :ref:`section_dc` DC offset removal for further explanation.

   * HIRES_MAX_DELAY

     This defines the length of the high resolution delay lines. This should be set to a power
	 of two for efficiency. The default is 256. Increasing values will result in increasing memory
	 usage.
	 
Four Channel Decimator
----------------------

The four channel decimator tasks are highly configurable tasks for outputting frames of 
various sizes and formats. They can be used to produce frames suitable for time domain applications
or pre-process the frames ready for an FFT for frequency domain applications. The four 
channel decimators, ``decimate_to_pcm_4ch()``, have a number of configuration options 
controlled by the structure ``decimator_config`` through the function ``decimator_configure``. 
The decimators are controlled by two structures: ``decimator_config_common`` and ``decimator_config``, 
where the former configuration is common to all microphones and the later is specific to the batch of 4
microphones it interfaces to. The application has the option to control the
following settings through ``decimator_config_common``:

* ``frame_size_log2``: This sets the frame size to a power of two. A frame will contain 
  2 to the power of frame_size_log2 samples of each channel. Set this to a maximum of ``MAX_FRAME_SIZE_LOG2``.
  
* ``apply_dc_offset_removal``: This controls if the DC offset removal should be enabled
  or not. Set to non-zero to enable, or ``0`` to not apply DC offset removal.
  
* ``output_decimation_factor``: This specifies the decimation factor to apply to the PDM input
  after a 8x decimtor and 4x decimator has already been applied, i.e. for s 3.072MHz PDM clock the 
  ``output_decimation_factor`` will apply to a 96kHz sample rate. The default valid values
  are 2, 4, 6, 8, 12, 16. Common sample rates can be achieved by using
  these decimation factors as follows:

  ======================== ===================== ======== ========== =============
  output_decimation_factor decimate_to_pcm_4x    PDM_rx   PDM clock  Sample rate
  ======================== ===================== ======== ========== =============
  2                        8 x                   8 x      3.072 MHz  48 KHz
  4                        16 x                  8 x      3.072 MHz  24 KHz
  6                        24 x                  8 x      3.072 MHz  16 KHz
  8                        32 x                  8 x      3.072 MHz  12 KHz
  12                       48 x                  8 x      3.072 MHz  8 KHz
  2                        8 x                   8 x      2.8224 MHz 44.1 KHz
  4                        16 x                  8 x      2.8224 MHz 22.05 KHz
  ======================== ===================== ======== ========== =============
  
* ``coefs``: This is a pointer to an array of arrays containing the
  coefficients for the final stage of decimation. Set this to
  ``FIR_LUT(d)`` where ``d`` is the ``fir_decimation_factor``; ``FIR_LUT()``
  is defined in ``fir_decimator.h``.
  If you wish to supply your own FIR coefficients; the array
  should have the same number of entries as ``fir_decimation_factor``.
  
* ``fir_gain_compensation`` single value to compensate the gain of all the
  previous decimators. This must be set to a value that depends on the
  ``fir_decimation_factor`` as follows:
  
  ======================== =======================
  output_decimation_factor fir_gain_compression
  ======================== =======================
  2                         FIR_COMPENSATOR_DIV_2
  4                         FIR_COMPENSATOR_DIV_4
  6                         FIR_COMPENSATOR_DIV_6
  8                         FIR_COMPENSATOR_DIV_8
  12                        FIR_COMPENSATOR_DIV_12
  ======================== =======================
  
  If you wish to supply your own, this is a fixed point number in 5.27 format. And to apply
  a unity gain the set to ``0``.
  
* ``apply_mic_gain_compensation``: Set this to ``1`` if microphone gain compensation is 
  required. The compensation applied is controlled through the
  ``mic_gain_compensation`` array in ``decimator_config`` below.
  
* A windowing function can be passed in through ``windowing_function``. It is a pointer
  to an array of integers that defines the windowing operator. Each sample
  in the frame is multiplied by its associated window value and shifted
  right by 31 places. This is performed before any index bit reversal (see
  the next entry). The window function data is in 1.31 fixed point format and only the first half
  of the window function is required.
  
* If the data is going to be post processed using an FFT, then
  ``index_bit_reversal`` can be set to 1. This will store the data elements
  reordered according to a reversed bit pattern, suitable for an FFT
  without "index bit reversing". As a side effect, it stores the data as
  complex numbers, in such a way that a single complex FFT operates on two
  microphones in parallel.

* ``buffering_type`` is used to specify half frame overlapping or sequential 
  frames.

* ``number_of_frame_buffers`` is used to specify the umber of frames used by the 
  application plus decimators.

``decimator_config`` configures the per-channel information:

* ``dcc``: This is a pointer to the common decimator configuration.
  
* ``data``: This is the memory used to save the FIR samples. It must be an
  array of size (4 channels x ``THIRD_STAGE_COEFS_PER_STAGE`` x ``sizeof(int)`` x
  ``fir_decimation_factor`` bytes).
  
* ``mic_gain_compensation``: This is an array with four elements specifying
  the relative compensation to apply to each microphone. Unity gain is
  given by the value ``INT_MAX``. To equalise the gain of all microphones,
  the quietest microphone should be given unity gain, and the gain of all
  other microphones should be set proportionally lower.

* ``channel_count``: this is the number of channels that is enabled. Set
  this to 4 to enable all channels. If set to a value less than 4, only the
  first ``channel_count`` channels are enabled.

The decimator configuration is applied, from the application, by calling
the function ``decimator_configure`` with an array of chanends referring to
the decimators, a count of the number of decimators, and an array of
decimator configurations.

The output of the decimator is 32bit PCM audio at the requested sample rate. 
 
Intended usage model
--------------------

The library has been designed with the intention of being able to dynamically 
change sample rates and other configurations, however, for minimal memory 
footprint choosing a single output rate means the fewest FIR coefficient 
end up in the binary.
A typical code structure will contain the following::

  unsigned buffer;
  decimator_init_audio_frame(c_ds_output, 2, buffer, audio, dcc);

  while(1){
    frame_audio *  latest_frame = decimator_get_next_audio_frame(c_ds_output, 2, buffer, audio, dcc);

  }
	
 
The ``buffer`` variable is not intended to be used by the application, it is an index used 
by ``lib_mic_array`` for keeping track of ownership of the frame buffers. 
The pointer to the latest frame, ``latest_frame``, is a pointer to a frame that the 
application is allowed to access. When a frame buffer of size N is being used then, in non-frame 
overlapping, mode the user has up to N-1 frames that can be accessed (one is always
in the possession of the decimators). In half frame overlapping mode there would be N-2 
frames available to the application as two are always in the possession of the decimators.

When a reconfigure is performed then there will be a short interval (to flush the FIR data buffers)
before the audio continues.

Overlapping frames are supported so that frequency domain algorithms can be converted back into the 
time domain without artifacts. See ``lib_dsp`` for FFT functions.
 

Frame and FIR memory
--------------------

For each decimator a block of memory must be allocated for storing FIR data. The size of the data 
block must be::
  
  4 channels * THIRD_STAGE_COEFS_PER_STAGE * Decimation factor * sizeof(int)

bytes. The data must also be double word aligned. For example, if the decimation factor was set to 
``DECIMATION_FACTOR`` then the memory allocation for the FIR memory would look like::

  int data_0[4*THIRD_STAGE_COEFS_PER_STAGE*DECIMATION_FACTOR] = {0};
  int data_1[4*THIRD_STAGE_COEFS_PER_STAGE*DECIMATION_FACTOR] = {0};

The FIR memory must also be initialized in order to prevent a spurious click during startup. 
Normally initializing to all zeros is sufficient. Also the frame memory must also be a double 
word aligned array of length of at least 2. 

Note, globally declared memory is always double word aligned.


.. _section_examples:

Example Applications
--------------------

Two stand alone applications showing the minimum code required to build a functioning
microphone array are given in ``AN00217_app_high_resolution_delay_example`` and in 
``AN00220_app_phase_aligned_example``. 

A worked example of a fixed beam delay and sum beamformer given in the application
``AN00219_app_lores_DAS_fixed``. Also examples of of how to set up high resolution delayed 
sampling can be seen in the high resolution fixed beam delay and sum beamformer given 
in the application ``AN00218_app_hires_DAS_fixed``. 
 
.. _section_dc:

DC offset removal
-----------------

The DC offset removal is implemented as a single pole IIR high pass filer obeying the 
relation::

  Y[n] = Y[n-1] * alpha + x[n] - x[n-1]

Where ``alpha`` is defined as ``1 - 2^DC_OFFSET_DIVIDER_LOG2``. Increasing ``DC_OFFSET_DIVIDER_LOG2``
will increase the stability of the filter and decrease the cut off point at the cost of slow settling
time. Decreasing ``DC_OFFSET_DIVIDER_LOG2`` will increase the cut off point of the filter. 
 

Signal Characteristics
----------------------

The output signal has been decimated from the original PDM in such a way to achieve at 
least 100dB of signal to noise for all output sample rates.

  =================== ================= ====================== ============ ============
  PDM Sample Rate(Hz) decimation_factor Output sample rate(Hz) Passband(Hz) Stopband(Hz)
  =================== ================= ====================== ============ ============
  3072000             2                 48000                  19200        26400
  3072000             4                 24000                  9600         13200
  3072000             6                 16000                  6400         8800
  3072000             8                 12000                  4800         6600
  3072000             12                8000                   3200         4400
  2822400             2                 44100                  17640        24255
  2822400             4                 22050                  8820         12127.5
  2822400             6                 14700                  5880         8085
  2822400             8                 11025                  4410         6063.75
  2822400             12                7350                   2940         4042.5
  =================== ================= ====================== ============ ============

The decimation is achieved by applying three poly-phase FIR filters sequentially. 
The design of these filters can be viewed in the python script ``fir_design.py``. The default 
magnitude responses of the first to third stages are given as :ref:`figthird_stage_div_2` 
through to :ref:`figthird_stage_div_12` in the appendix. The first stage and second stage 
can be viewed in :ref:`figfirst_stage` and :ref:`figsecond_stage`.

Advanced filter design
......................

The above table has been generated to provide 100dB of signal to noise for all decimation factors
whilst maintaining a fairly flat passband and wide bandwidth. However for a given specification 
the filter characteristics can be optimised to reduce latency, increase passband, lower the 
passband ripple and increase the signal to noise ratio. For example, in a system where a 16kHz
output is required then limiting the passband to 8kHz would improve the other properties. Equally, 
if the noise floor of the PDM microphone is 65dB then there is little advantage exceeding that in the
filter. 

``fir_design.py`` usage
.......................
 
In order generate custom filters the ``fir_design.py`` can be executed. The purpose of this file 
is to design end generate the FIR coefficients for the three stages of decimation. ``fir_design.py`` 
is a command line tool that takes a number of command line options to control each parameter of the
filter design. As previously illustrated the PDM to PCM conversion is divided into three stages. 
The overall noise floor is governed with the option ``--stopband-attenuation``. This should be a 
positive number of decibels between 20 and 120. In the first stage of design the designer is able 
to tune:

* passband bandwidth(``--first-stage-pass-bw``) - The bandwidth of the passband, in kHz.
* stopband bandwidth(``--first-stage-stop-bw``) - The bandwidth of the bands around the regions that will alias with the pass band after decimation, in kHz.

These are illustrated in :ref:`figfirst`.

  .. _figfirst:
  .. figure:: first_stage_diagram.pdf
	:width: 100%
	    
	First stage design parameters.

In the second stage the same options are available:

* passband bandwidth(``--second-stage-pass-bw``) - The bandwidth of the passband, in kHz.
* stopband bandwidth(``--second-stage-stop-bw``) - The bandwidth of the bands around the regions that will alias with the pass band after decimation, in kHz.

These are illustrated in :ref:`figsecond`.

  .. _figsecond:
  .. figure:: second_stage_diagram.pdf
	:width: 100%
	    
	Second stage design parameters.

In the third stage the designer can provide custom decimation factors and pass and stop band parameters.
Also the delay of the filter can be controlled by tuning the number of taps to allocate for each phase of
the poly-phase FIR (``--third-stage-num-taps``). The fewer the number of taps per phase then the shorter the
delay of the filter but the harder the design will be to meet other criteria.

To add a custom third stage filter ``--add-third-stage`` has to be called. It required the following arguments:

* decimation factor - the ratio of input samples to output samples
* normalized output passband - This specifies where the passband ends.
* normalized output stopband - This specified where the stopband starts.
* name - This assigns a name to the custom filter.

These are illustrated in figure :ref:`figthird`.

  .. _figthird:
  .. figure:: third_stage_diagram.pdf
	:width: 100%
	    
	Third stage design parameters.

The name is used to generate the defines and coefficient arrays used to implement the filter in ``lib_mic_array``.
The defines ``DECIMATION_FACTOR_ + (filter_name)`` and ``FIR_COMPENSATOR_ + (filter_name)`` will be generated to
represent the filter designed. Additionally, the array ``const int g_third_stage_ + (filter_name) _fir[]`` will
also be generated and will contain all the coefficients to implement the filter.
For example, if ``fir_design.py`` was passed the option ``--add-third-stage 2 0.4 0.5 my_filter`` then available 
in ``lib_mic_array`` would be::
 
  #define DECIMATION_FACTOR_MY_FILTER (2)
  #define FIR_COMPENSATOR_MY_FILTER ((int)((double)(INT_MAX>>4) * FIRST_STAGE_SCALE_FACTOR * SECOND_STAGE_SCALE_FACTOR * MY_FILTER_SCALE_FACTOR))
  extern const int g_third_stage_my_filter_fir[126];

Following the execution for ``fir_fesidn.py``, the coefficients generated (``*.fir_coefs``) have to be 
converted into ``fir_coefs.xc`` and``fir_decimator.h`` by running ``java -jar Generator.jar``. This takes 
the raw coefficients and preprocesses them to maximise the dynamic range and efficiency within the compiled 
application.


.. _section_api:

API
---

Creating an PDM microphone interface instance
.............................................

.. doxygenfunction:: pdm_rx

|newpage|

PDM microphone processing
.........................

.. doxygenfunction:: decimate_to_pcm_4ch
.. doxygenfunction:: decimator_configure
.. doxygenstruct:: decimator_config_common
.. doxygenstruct:: decimator_config

|newpage|

PCM frame interfacing
.....................

.. doxygenenum:: e_decimator_buffering_type
.. doxygenfunction:: decimator_init_audio_frame
.. doxygenfunction:: decimator_get_next_audio_frame
.. doxygenfunction:: decimator_init_complex_frame
.. doxygenfunction:: decimator_get_next_complex_frame

|newpage|

Frame types
...........

.. doxygenstruct:: complex
.. doxygenstruct:: frame_audio
.. doxygenstruct:: frame_complex

High resolution delay task
..........................

.. doxygenfunction:: hires_delay
.. doxygenfunction:: hires_delay_set_taps

|newpage|
|appendix|


.. _figfirst_stage:
.. figure:: first_stage.eps
            :width: 70%
                    
            First stage FIR magnitude response.


.. _figsecond_stage:
.. figure:: second_stage.eps
            :width: 70%
                    
            Second stage FIR magnitude response.


.. _figthird_stage_div_2:
.. figure:: third_stage_div_2.eps
            :width: 70%
                    
            Third stage FIR magnitude response for a divide of 2.


.. _figthird_stage_div_4:
.. figure:: third_stage_div_4.eps
            :width: 70%
                    
            Third stage FIR magnitude response for a divide of 4.


.. _figthird_stage_div_6:
.. figure:: third_stage_div_6.eps
            :width: 70%
                    
            Third stage FIR magnitude response for a divide of 6.


.. _figthird_stage_div_8:
.. figure:: third_stage_div_8.eps
            :width: 70%
                    
            Third stage FIR magnitude response for a divide of 8.


.. _figthird_stage_div_12:
.. figure:: third_stage_div_12.eps
            :width: 70%
                    
            Third stage FIR magnitude response for a divide of 12.

				
|newpage|

Known Issues
------------

  * decimator_config channel count is tested for 4 channels per decimator, few than 4 is untested.
  * Generator currently under calculated the FIR compensation factor, use 0 (unity gain) until corrected.

.. include:: ../../../CHANGELOG.rst
